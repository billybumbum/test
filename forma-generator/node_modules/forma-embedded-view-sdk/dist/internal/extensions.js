var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ExtensionsApi_iframeMessenger, _Storage_iframeMessenger, _Storage_textDecoder;
export class ExtensionsApi {
    constructor(iframeMessenger) {
        _ExtensionsApi_iframeMessenger.set(this, void 0);
        __classPrivateFieldSet(this, _ExtensionsApi_iframeMessenger, iframeMessenger, "f");
        this.storage = new Storage(iframeMessenger);
    }
    async invokeEndpoint(request) {
        return await __classPrivateFieldGet(this, _ExtensionsApi_iframeMessenger, "f").sendRequest("extensions/invoke-endpoint", request);
    }
}
_ExtensionsApi_iframeMessenger = new WeakMap();
/**
 * @namespace Storage
 *
 * Extension storage provides a way for extension authors to save data in a given authcontext
 * the extension is installed in without needing their own storage layer.
 *
 * Any data can be stored, and by using presigned URLs, data is stored and fetched directly via the
 * embedded view. Data is stored in AWS S3 and we provide extension authors with presigned URLs
 * for objects to be stored and fetched. This way we only act as a proxy for generating the presigned links
 * without ever having an opinion on what data is actually stored.
 *
 * NOTE: Even though extension authors can write data on behalf of a user in a specific context, it's
 * still the user who owns the data, and can they can access it without going through the extension
 * itself.
 *
 * @see https://aws.amazon.com/s3/
 */
class Storage {
    constructor(iframeMessenger) {
        _Storage_iframeMessenger.set(this, void 0);
        _Storage_textDecoder.set(this, new TextDecoder());
        __classPrivateFieldSet(this, _Storage_iframeMessenger, iframeMessenger, "f");
    }
    /**
     * Add a an object to storage
     *
     * @example
     * // STORE JSON
     * const myObject = {
     *  someData: "someValue"
     * }
     *
     * await Forma.extensions.storage.setObject({key: "some-key", data: JSON.stringify(myObject)})
     *
     * @example
     * // STORE Float32Array
     *
     * function arrayToBuffer(array: Float32Array): ArrayBuffer {
     *   const buffer = new ArrayBuffer(array.length * Float32Array.BYTES_PER_ELEMENT);
     *   const arr = new Float32Array(buffer);
     *   arr.set(array);
     *   return arr;
     * }
     *
     * const arr = new Float32Array(100).fill(Math.random())
     * await Forma.extensions.storage.setObject({key: "someKey", data: arrayToBuffer(arr)})
     *
     */
    async setObject(request) {
        const url = await __classPrivateFieldGet(this, _Storage_iframeMessenger, "f").sendRequest("extension-installation-storage/set", {
            key: request.key,
            metadata: request.metadata,
        });
        const awsRes = await fetch(url, {
            method: "PUT",
            body: request.data,
        });
        if (!awsRes.ok) {
            throw new Error(`Failed to put data to S3: ${awsRes.status}: ${awsRes.statusText}`);
        }
    }
    /**
     * Utility function to fetch string objects without needing to decode an array buffer
     *
     * @example
     * // READING JSON
     * const res = await Forma.extensions.storage.getTextObject({key: "some-key"})
     * if (!res) {
     *    return
     * }
     * const metadata = JSON.parse(data.metadata ?? "{}")
     * const data = res.data
     *
     * @example
     * function loadImageFromEncodedPng(url: string): Promise<HtmlImageElement> {
     *   return new Promise((resolve, reject) => {
     *     const img = new Image()
     *     img.onload = () => {
     *       resolve(img)
     *     }
     *     img.onerror = () => {
     *       reject(new Error("Failed to load image"))
     *     }
     *     img.src = url
     *   })
     * }
     *
     * async function createCanvasFromDataUrl(url: string): Promise<HtmlCanvasElement | void> {
     *  const canvas = document.createElement("canvas")
     *  const ctx = canvas.getContext("2d")
     *  const img = await loadImage(url)
     *  canvas.height = img.height
     *  canvas.width = img.width
     *  ctx.drawImage(ctx, img, 0, 0)
     *  return canvas
     * }
     *
     * const res = await Forma.extensions.storage.getTextObject({key: "some-png-key"})
     * if (!res) {
     *    return
     * }
     * const canvas = createCanvasFromDataUrl(res.data)
     *
     */
    async getTextObject(request) {
        const res = await __classPrivateFieldGet(this, _Storage_iframeMessenger, "f").sendRequest("extension-installation-storage/get", request);
        if (!res) {
            return;
        }
        return {
            ...res,
            data: __classPrivateFieldGet(this, _Storage_textDecoder, "f").decode(res.data),
        };
    }
    /**
     *
     * Fetch the data on the specific key provided
     *
     * Use this function when you're **not** fetching text data, such as geometry
     * or analysis results
     *
     * @example
     * const res = await Forma.extensions.storage.getBinaryObject({key: "my-float32-array"})
     * if (!res) {
     *  return
     * }
     * const terrainSlope: Float32Array = new Float32Array(res.data)
     * const metadata = JSON.parse(res.metadata ?? "{}")
     *
     */
    async getBinaryObject(request) {
        return await __classPrivateFieldGet(this, _Storage_iframeMessenger, "f").sendRequest("extension-installation-storage/get", request);
    }
    /**
     * List all storage objects for the extension in the current authcontext
     */
    async listObjects(request) {
        return await __classPrivateFieldGet(this, _Storage_iframeMessenger, "f").sendRequest("extension-installation-storage/list", request ?? {});
    }
    /**
     * Delete an object with the specific key
     */
    async deleteObject(request) {
        await __classPrivateFieldGet(this, _Storage_iframeMessenger, "f").sendRequest("extension-installation-storage/delete", request);
    }
}
_Storage_iframeMessenger = new WeakMap(), _Storage_textDecoder = new WeakMap();
