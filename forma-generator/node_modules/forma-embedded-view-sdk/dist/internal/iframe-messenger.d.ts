import { EventHandler, RequestHandler, SubscribeHandler } from "./types.js";
declare const messageTypeRequest = "IFRAME-MESSAGE-REQUEST";
declare const messageTypeResponse = "IFRAME-MESSAGE-RESPONSE";
declare const messageTypeEvent = "IFRAME-MESSAGE-EVENT";
export type IframeMessageEvent = {
    type: typeof messageTypeEvent;
    action: string;
    payload: unknown;
};
export type IframeMessageRequest = {
    /**
     * The ID is a unique identifier used to connect
     * the response message to the proper request.
     */
    id: string;
    type: typeof messageTypeRequest;
    action: string;
    payload: unknown;
};
export type IframeMessageResponse = {
    /**
     * The ID is a unique identifier used to connect
     * the response message to the proper request.
     */
    id: string;
    type: typeof messageTypeResponse;
    payload: unknown;
    error?: boolean | undefined;
};
export type CreateSubscriptionResult = {
    unsubscribe: () => void;
};
export type IframeMessengerOptions = {
    source: Window;
    /**
     * The origin where messages are expected from and that we will
     * use as destination for outgoing messages.
     *
     * Set to undefined if not checking origin in incoming messages
     * and sending outgoing messages to "*".
     *
     * Do not use undefined in the configuration side of an iframe if
     * sending sensitive data such as credentials.
     */
    sourceOrigin?: string | undefined;
    requestResolver?: ((action: string) => RequestHandler | undefined) | undefined;
    eventResolver?: ((action: string) => EventHandler | undefined) | undefined;
    subscribeResolver?: ((name: string) => SubscribeHandler | undefined) | undefined;
    debug?: boolean | undefined;
};
type DeregisterFn = () => void;
/**
 * IframeMessenger handles communication in/out of an iframe.
 *
 * It creates an abstraction on top of the Window.postMessage() browser
 * API to make it more convenient to handle states, message passing
 * and routing messages to handlers.
 *
 * Functionality provided:
 *
 * - Sending requests and waiting for the response for it. Think of it
 *   as a way of doing async functions across browser windows. Since the
 *   cross-window communcation is async itself, there is no support for
 *   synchronous requests.
 *
 * - Sending events to the other window. Events are one-way messages that
 *   do not expect a reply. Use cases for this is rare, and in most
 *   cases solved by subscriptions instead.
 *
 * - Subscriptions. This is a way to subscribe to specific events from the
 *   other window. The window that exposes a subscription source will contain
 *   a handler that can emit events for it when the subscription is created.
 *   This allows for lazy event streams that are only created when needed.
 *
 *   Internally subscriptions are built on top of both requests (creating and
 *   deleting subscriptions) and events mentioned above.
 *
 *   Subscriptions are unsubscribed automatically on disconnect.
 *
 * - Connected callbacks. This allows to add logic that should happen
 *   as soon as the connection between the windows are established.
 *
 * By default messages are queued until the connection is established,
 * so the user does not have to be concerned about connection details.
 *
 * When an iframe is removed from DOM, the connection should be explicitly
 * disconnected by calling disconnect() to trigger proper cleanup.
 */
export declare class IframeMessenger {
    #private;
    source: Window;
    sourceOrigin: string | undefined;
    requestResolver: ((action: string) => RequestHandler | undefined) | undefined;
    eventResolver: ((action: string) => EventHandler | undefined) | undefined;
    subscribeResolver: ((name: string) => SubscribeHandler | undefined) | undefined;
    constructor(options: IframeMessengerOptions);
    connect(): void;
    disconnect(): void;
    /**
     * Add a listener for when a connection is established.
     *
     * Only invoked for new state transitions after the listener is registered.
     *
     * @return Cleanup method to deregister the listener
     */
    onConnected(handler: () => void): DeregisterFn;
    get isConnected(): boolean;
    connectedPromise(): Promise<void>;
    sendRequest<T, R>(action: string, payload: T): Promise<R>;
    sendEvent<T>(action: string, payload: T): Promise<void>;
    createSubscription<T, O extends Record<string, unknown> = Record<string, unknown>>(name: string, handler: (event: T) => void, options?: O | undefined): Promise<CreateSubscriptionResult>;
}
export {};
