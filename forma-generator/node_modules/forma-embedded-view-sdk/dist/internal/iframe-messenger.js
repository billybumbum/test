var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _IframeMessenger_instances, _IframeMessenger_state, _IframeMessenger_connectedHandlers, _IframeMessenger_subscriptionEventHandlers, _IframeMessenger_unsubscribeHandlers, _IframeMessenger_debug, _IframeMessenger_messageHandler, _IframeMessenger_handleConnectAction, _IframeMessenger_handleDisconnectAction, _IframeMessenger_handleEvent, _IframeMessenger_getRequestHandler, _IframeMessenger_handleRequest, _IframeMessenger_receive, _IframeMessenger_sendRequestInternal, _IframeMessenger_sendEventInternal, _IframeMessenger_postMessage, _IframeMessenger_getTargetOrigin, _IframeMessenger_removeSubscription, _IframeMessenger_unsubscribeAllHandlers, _IframeMessenger_handleCreateSubscriptionRequest, _IframeMessenger_handleRemoveSubscriptionRequest, _IframeMessenger_handleSubscriptionEvent;
import * as uuid from "uuid";
const messageTypeRequest = "IFRAME-MESSAGE-REQUEST";
const messageTypeResponse = "IFRAME-MESSAGE-RESPONSE";
const messageTypeEvent = "IFRAME-MESSAGE-EVENT";
const connectEventAction = "_connect";
const disconnectEventAction = "_disconnect";
const createSubscriptionRequestAction = "_createSubscription";
const removeSubscriptionRequestAction = "_removeSubscription";
const subscriptionEventAction = "_subscriptionEvent";
/** Check if the message data received is a request. */
function isRequest(data) {
    return (typeof data === "object" &&
        data != null &&
        "id" in data &&
        "action" in data &&
        "type" in data &&
        data.type === messageTypeRequest);
}
/** Check if the message data received is a response. */
function isResponse(data) {
    return (typeof data === "object" &&
        data != null &&
        "id" in data &&
        "type" in data &&
        data.type == messageTypeResponse);
}
/** Check if the message data received is an event. */
function isEvent(data) {
    return (typeof data === "object" &&
        data != null &&
        "action" in data &&
        "type" in data &&
        data.type === messageTypeEvent);
}
var State;
(function (State) {
    /** While initialized it will also respond to connect events. */
    State["INITIALIZED"] = "initialized";
    /** The connecting state means we have sent a connect message. */
    State["CONNECTING"] = "connecting";
    State["ESTABLISHED"] = "established";
    State["DISCONNECTED"] = "disconnected";
})(State || (State = {}));
/**
 * IframeMessenger handles communication in/out of an iframe.
 *
 * It creates an abstraction on top of the Window.postMessage() browser
 * API to make it more convenient to handle states, message passing
 * and routing messages to handlers.
 *
 * Functionality provided:
 *
 * - Sending requests and waiting for the response for it. Think of it
 *   as a way of doing async functions across browser windows. Since the
 *   cross-window communcation is async itself, there is no support for
 *   synchronous requests.
 *
 * - Sending events to the other window. Events are one-way messages that
 *   do not expect a reply. Use cases for this is rare, and in most
 *   cases solved by subscriptions instead.
 *
 * - Subscriptions. This is a way to subscribe to specific events from the
 *   other window. The window that exposes a subscription source will contain
 *   a handler that can emit events for it when the subscription is created.
 *   This allows for lazy event streams that are only created when needed.
 *
 *   Internally subscriptions are built on top of both requests (creating and
 *   deleting subscriptions) and events mentioned above.
 *
 *   Subscriptions are unsubscribed automatically on disconnect.
 *
 * - Connected callbacks. This allows to add logic that should happen
 *   as soon as the connection between the windows are established.
 *
 * By default messages are queued until the connection is established,
 * so the user does not have to be concerned about connection details.
 *
 * When an iframe is removed from DOM, the connection should be explicitly
 * disconnected by calling disconnect() to trigger proper cleanup.
 */
export class IframeMessenger {
    constructor(options) {
        _IframeMessenger_instances.add(this);
        _IframeMessenger_state.set(this, State.INITIALIZED);
        _IframeMessenger_connectedHandlers.set(this, []
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        );
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        _IframeMessenger_subscriptionEventHandlers.set(this, new Map());
        _IframeMessenger_unsubscribeHandlers.set(this, new Map());
        _IframeMessenger_debug.set(this, void 0);
        _IframeMessenger_messageHandler.set(this, (message) => {
            // This method will be called on all "message" events.
            // We need to filter only those we want to handle.
            const source = message.source;
            if (source == null ||
                source !== this.source ||
                (this.sourceOrigin != null && message.origin !== this.sourceOrigin)) {
                return;
            }
            if (__classPrivateFieldGet(this, _IframeMessenger_debug, "f")) {
                console.log(`Message from origin ${message.origin}:`, message.data);
            }
            if (isEvent(message.data)) {
                __classPrivateFieldGet(this, _IframeMessenger_instances, "m", _IframeMessenger_handleEvent).call(this, message.data);
            }
            if (isRequest(message.data)) {
                __classPrivateFieldGet(this, _IframeMessenger_instances, "m", _IframeMessenger_handleRequest).call(this, message.data, message, source);
            }
        });
        this.source = options.source;
        this.sourceOrigin = options.sourceOrigin;
        this.requestResolver = options.requestResolver;
        this.eventResolver = options.eventResolver;
        this.subscribeResolver = options.subscribeResolver;
        __classPrivateFieldSet(this, _IframeMessenger_debug, options.debug ?? false, "f");
        window.addEventListener("message", __classPrivateFieldGet(this, _IframeMessenger_messageHandler, "f"));
    }
    connect() {
        if (__classPrivateFieldGet(this, _IframeMessenger_state, "f") === State.INITIALIZED ||
            __classPrivateFieldGet(this, _IframeMessenger_state, "f") === State.DISCONNECTED) {
            __classPrivateFieldSet(this, _IframeMessenger_state, State.CONNECTING, "f");
            __classPrivateFieldGet(this, _IframeMessenger_instances, "m", _IframeMessenger_sendEventInternal).call(this, connectEventAction, null, false).catch((e) => {
                console.error("Sending connect action failed", e);
            });
        }
    }
    disconnect() {
        __classPrivateFieldSet(this, _IframeMessenger_state, State.DISCONNECTED, "f");
        __classPrivateFieldGet(this, _IframeMessenger_instances, "m", _IframeMessenger_sendEventInternal).call(this, disconnectEventAction, null, false).catch((e) => {
            console.error("Sending disconnect action failed", e);
        });
        __classPrivateFieldGet(this, _IframeMessenger_instances, "m", _IframeMessenger_unsubscribeAllHandlers).call(this);
    }
    /**
     * Add a listener for when a connection is established.
     *
     * Only invoked for new state transitions after the listener is registered.
     *
     * @return Cleanup method to deregister the listener
     */
    onConnected(handler) {
        __classPrivateFieldGet(this, _IframeMessenger_connectedHandlers, "f").push(handler);
        return () => {
            __classPrivateFieldSet(this, _IframeMessenger_connectedHandlers, __classPrivateFieldGet(this, _IframeMessenger_connectedHandlers, "f").filter((it) => it !== handler), "f");
        };
    }
    get isConnected() {
        return __classPrivateFieldGet(this, _IframeMessenger_state, "f") === State.ESTABLISHED;
    }
    connectedPromise() {
        if (this.isConnected) {
            return Promise.resolve();
        }
        if (__classPrivateFieldGet(this, _IframeMessenger_debug, "f")) {
            console.log("connectedPromise waiting for connection...");
        }
        return new Promise((resolve) => {
            const deregister = this.onConnected(() => {
                if (__classPrivateFieldGet(this, _IframeMessenger_debug, "f")) {
                    console.log("connectedPromise resolved!");
                }
                deregister();
                resolve();
            });
        });
    }
    async sendRequest(action, payload) {
        return __classPrivateFieldGet(this, _IframeMessenger_instances, "m", _IframeMessenger_sendRequestInternal).call(this, action, payload, true);
    }
    async sendEvent(action, payload) {
        await __classPrivateFieldGet(this, _IframeMessenger_instances, "m", _IframeMessenger_sendEventInternal).call(this, action, payload, true);
    }
    async createSubscription(name, handler, options) {
        const subscriptionId = uuid.v4();
        __classPrivateFieldGet(this, _IframeMessenger_subscriptionEventHandlers, "f").set(subscriptionId, handler);
        if (__classPrivateFieldGet(this, _IframeMessenger_debug, "f")) {
            console.log(`Creating subscription with ID ${subscriptionId} for ${name}`);
        }
        try {
            const payload = {
                subscriptionId,
                name,
            };
            if (options) {
                payload.options = options;
            }
            await __classPrivateFieldGet(this, _IframeMessenger_instances, "m", _IframeMessenger_sendRequestInternal).call(this, createSubscriptionRequestAction, payload, true);
        }
        catch (e) {
            throw new Error("Failed to create subscription", { cause: e });
        }
        return {
            unsubscribe: () => {
                if (__classPrivateFieldGet(this, _IframeMessenger_debug, "f")) {
                    console.log(`Unsubscribing from subscription ${subscriptionId} for ${name}`);
                }
                __classPrivateFieldGet(this, _IframeMessenger_subscriptionEventHandlers, "f").delete(subscriptionId);
                __classPrivateFieldGet(this, _IframeMessenger_instances, "m", _IframeMessenger_removeSubscription).call(this, subscriptionId);
            },
        };
    }
}
_IframeMessenger_state = new WeakMap(), _IframeMessenger_connectedHandlers = new WeakMap(), _IframeMessenger_subscriptionEventHandlers = new WeakMap(), _IframeMessenger_unsubscribeHandlers = new WeakMap(), _IframeMessenger_debug = new WeakMap(), _IframeMessenger_messageHandler = new WeakMap(), _IframeMessenger_instances = new WeakSet(), _IframeMessenger_handleConnectAction = function _IframeMessenger_handleConnectAction(payload) {
    if (__classPrivateFieldGet(this, _IframeMessenger_state, "f") !== State.INITIALIZED && __classPrivateFieldGet(this, _IframeMessenger_state, "f") !== State.CONNECTING) {
        return;
    }
    __classPrivateFieldSet(this, _IframeMessenger_state, State.ESTABLISHED, "f");
    if (!payload?.ack) {
        const response = {
            ack: true,
        };
        __classPrivateFieldGet(this, _IframeMessenger_instances, "m", _IframeMessenger_sendEventInternal).call(this, connectEventAction, response, false).catch((e) => {
            console.error("Sending event failed", e);
        });
    }
    for (const handler of __classPrivateFieldGet(this, _IframeMessenger_connectedHandlers, "f")) {
        try {
            handler();
        }
        catch (e) {
            console.error("Connect handler failed", e);
        }
    }
}, _IframeMessenger_handleDisconnectAction = function _IframeMessenger_handleDisconnectAction(payload) {
    if (__classPrivateFieldGet(this, _IframeMessenger_state, "f") === State.DISCONNECTED) {
        return;
    }
    __classPrivateFieldSet(this, _IframeMessenger_state, State.DISCONNECTED, "f");
    __classPrivateFieldGet(this, _IframeMessenger_instances, "m", _IframeMessenger_unsubscribeAllHandlers).call(this);
    if (!payload?.ack) {
        const response = {
            ack: true,
        };
        __classPrivateFieldGet(this, _IframeMessenger_instances, "m", _IframeMessenger_sendEventInternal).call(this, disconnectEventAction, response, false).catch((e) => {
            console.error("Sending event failed", e);
        });
    }
}, _IframeMessenger_handleEvent = function _IframeMessenger_handleEvent(message) {
    if (message.action === connectEventAction) {
        __classPrivateFieldGet(this, _IframeMessenger_instances, "m", _IframeMessenger_handleConnectAction).call(this, message.payload);
        return;
    }
    if (message.action === disconnectEventAction) {
        __classPrivateFieldGet(this, _IframeMessenger_instances, "m", _IframeMessenger_handleDisconnectAction).call(this, message.payload);
        return;
    }
    if (message.action === subscriptionEventAction) {
        __classPrivateFieldGet(this, _IframeMessenger_instances, "m", _IframeMessenger_handleSubscriptionEvent).call(this, message.payload);
    }
    if (this.eventResolver) {
        const handler = this.eventResolver(message.action);
        if (handler == null) {
            console.warn("Unknown action for message", message);
            return;
        }
        handler(message.payload);
    }
}, _IframeMessenger_getRequestHandler = function _IframeMessenger_getRequestHandler(action) {
    switch (action) {
        case createSubscriptionRequestAction:
            return __classPrivateFieldGet(this, _IframeMessenger_instances, "m", _IframeMessenger_handleCreateSubscriptionRequest).bind(this);
        case removeSubscriptionRequestAction:
            return __classPrivateFieldGet(this, _IframeMessenger_instances, "m", _IframeMessenger_handleRemoveSubscriptionRequest).bind(this);
        default:
            return this.requestResolver?.(action);
    }
}, _IframeMessenger_handleRequest = function _IframeMessenger_handleRequest(request, event, source) {
    const reply = (payload, error) => {
        const response = {
            id: request.id,
            type: messageTypeResponse,
            payload,
            error,
        };
        const targetOrigin = __classPrivateFieldGet(this, _IframeMessenger_instances, "m", _IframeMessenger_getTargetOrigin).call(this, event.origin);
        if (__classPrivateFieldGet(this, _IframeMessenger_debug, "f")) {
            console.log(`Sending message to ${targetOrigin}:`, response);
        }
        source.postMessage(response, targetOrigin);
    };
    const handler = __classPrivateFieldGet(this, _IframeMessenger_instances, "m", _IframeMessenger_getRequestHandler).call(this, request.action);
    if (handler == null) {
        console.warn("Unknown action for request", request);
        reply(new Error(`Unknown action: ${request.action}`), true);
        return;
    }
    Promise.resolve()
        .then(() => handler(request.payload))
        .then((response) => {
        reply(response);
    })
        .catch((err) => {
        console.error(`Failed during request action ${request.action}`, err);
        reply(err, true);
    });
}, _IframeMessenger_receive = function _IframeMessenger_receive(id) {
    let callback;
    return new Promise((resolve, reject) => {
        callback = (event) => {
            if (event.source === this.source &&
                (this.sourceOrigin == null || event.origin === this.sourceOrigin) &&
                isResponse(event.data) &&
                event.data.id === id) {
                if (event.data.error) {
                    reject(event.data.payload);
                }
                else {
                    resolve(event.data.payload);
                }
            }
        };
        window.addEventListener("message", callback);
    }).finally(() => {
        window.removeEventListener("message", callback);
    });
}, _IframeMessenger_sendRequestInternal = async function _IframeMessenger_sendRequestInternal(action, payload, waitForConnected) {
    const id = uuid.v4();
    const responsePromise = __classPrivateFieldGet(this, _IframeMessenger_instances, "m", _IframeMessenger_receive).call(this, id);
    const message = {
        id,
        type: messageTypeRequest,
        action,
        payload,
    };
    const [response] = await Promise.all([
        responsePromise,
        __classPrivateFieldGet(this, _IframeMessenger_instances, "m", _IframeMessenger_postMessage).call(this, message, waitForConnected),
    ]);
    return response;
}, _IframeMessenger_sendEventInternal = async function _IframeMessenger_sendEventInternal(action, payload, waitForConnected) {
    const message = {
        type: messageTypeEvent,
        action,
        payload,
    };
    await __classPrivateFieldGet(this, _IframeMessenger_instances, "m", _IframeMessenger_postMessage).call(this, message, waitForConnected);
}, _IframeMessenger_postMessage = async function _IframeMessenger_postMessage(message, waitForConnected) {
    if (this.source == null) {
        throw new Error("Missing source");
    }
    const targetOrigin = __classPrivateFieldGet(this, _IframeMessenger_instances, "m", _IframeMessenger_getTargetOrigin).call(this, this.sourceOrigin);
    if (__classPrivateFieldGet(this, _IframeMessenger_debug, "f")) {
        console.log(`Sending message to ${targetOrigin}:`, message);
    }
    if (waitForConnected) {
        await this.connectedPromise();
    }
    this.source.postMessage(message, targetOrigin);
}, _IframeMessenger_getTargetOrigin = function _IframeMessenger_getTargetOrigin(value) {
    return value === "null" || value == null ? "*" : value;
}, _IframeMessenger_removeSubscription = function _IframeMessenger_removeSubscription(subscriptionId) {
    const payload = {
        subscriptionId,
    };
    __classPrivateFieldGet(this, _IframeMessenger_instances, "m", _IframeMessenger_sendRequestInternal).call(this, removeSubscriptionRequestAction, payload, true).catch((e) => {
        console.warn("Failed to remove subscription", e);
    });
}, _IframeMessenger_unsubscribeAllHandlers = function _IframeMessenger_unsubscribeAllHandlers() {
    for (const unsubscribe of __classPrivateFieldGet(this, _IframeMessenger_unsubscribeHandlers, "f").values()) {
        try {
            unsubscribe();
        }
        catch (e) {
            console.warn("Failed to unsubscribe", e);
        }
    }
    __classPrivateFieldGet(this, _IframeMessenger_unsubscribeHandlers, "f").clear();
    __classPrivateFieldGet(this, _IframeMessenger_subscriptionEventHandlers, "f").clear();
}, _IframeMessenger_handleCreateSubscriptionRequest = async function _IframeMessenger_handleCreateSubscriptionRequest(payload) {
    const subscribe = this.subscribeResolver?.(payload.name);
    if (!subscribe) {
        throw new Error(`Unknown subscription name: ${payload.name}`);
    }
    const sendEvent = (data) => {
        const event = {
            subscriptionId: payload.subscriptionId,
            data,
        };
        __classPrivateFieldGet(this, _IframeMessenger_instances, "m", _IframeMessenger_sendEventInternal).call(this, subscriptionEventAction, event, true).catch((err) => {
            console.error("Sending event failed", err);
        });
    };
    const { unsubscribe } = await subscribe(sendEvent, payload.options);
    __classPrivateFieldGet(this, _IframeMessenger_unsubscribeHandlers, "f").set(payload.subscriptionId, unsubscribe);
    return {
        ack: true,
    };
}, _IframeMessenger_handleRemoveSubscriptionRequest = function _IframeMessenger_handleRemoveSubscriptionRequest(payload) {
    const unsubscribe = __classPrivateFieldGet(this, _IframeMessenger_unsubscribeHandlers, "f").get(payload.subscriptionId);
    // Ignore if the subscription does not exist. Assume it has already been removed.
    if (unsubscribe) {
        unsubscribe();
        __classPrivateFieldGet(this, _IframeMessenger_unsubscribeHandlers, "f").delete(payload.subscriptionId);
    }
    return {
        ack: true,
    };
}, _IframeMessenger_handleSubscriptionEvent = function _IframeMessenger_handleSubscriptionEvent(event) {
    const subscriptionId = event.subscriptionId;
    const handler = __classPrivateFieldGet(this, _IframeMessenger_subscriptionEventHandlers, "f").get(subscriptionId);
    if (handler == null) {
        console.debug(`Unknown subscription ID: ${event.subscriptionId}`, event);
        return;
    }
    handler(event.data);
};
