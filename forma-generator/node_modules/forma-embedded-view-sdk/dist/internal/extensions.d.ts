import { IframeMessenger } from "./iframe-messenger.js";
export type ExtensionEndpointInvokeRequest = {
    /**
     * Authcontext to use with the request.
     *
     * As of now, only the currently open project is supported as
     * authcontext when using the SDK.
     *
     * @defaultValue The currently open project.
     */
    authcontext?: string | undefined;
    extensionId: string;
    endpointId: string;
    payload: unknown;
};
export declare class ExtensionsApi {
    #private;
    readonly storage: Storage;
    constructor(iframeMessenger: IframeMessenger);
    invokeEndpoint<T>(request: ExtensionEndpointInvokeRequest): Promise<T>;
}
/**
 * A string of metadata that can be stored on the object
 *
 * Can often be useful when storing binary data or png's
 * and you need to add some additional context on that particular object,
 * for example parameters that was used in an analysis calculation
 * that can remove unnecessary computation later
 *
 * NOTE: This will be returned in a specific HTTP header when fetching the object and is
 * restricted to 1kb in size.
 */
type Metadata = string;
export type StorageSetObjectRequest = {
    /**
     * The key of the object
     *
     * Max length: 200
     * Allowed characters: [a-zA-Z0-9!-_.*'()]
     */
    key: string;
    /**
     * Data to be stored
     */
    data: ArrayBuffer | string;
    metadata?: Metadata | undefined;
};
export type StorageGetObjectRequest = {
    /**
     * The key of the object
     */
    key: string;
};
export type StorageGetObjectResponse = {
    data: ArrayBuffer;
    metadata?: Metadata | undefined;
};
export type StorageGetBinaryObjectResponse = {
    /**
     * Data as arrayBuffer
     */
    data: ArrayBuffer;
    metadata?: Metadata | undefined;
};
export type StorageGetTextObjectResponse = {
    /**
     * Data formatted as utf-8 string.
     */
    data: string;
    metadata?: Metadata | undefined;
};
export type StorageListObjectsRequest = {
    /**
     * Limit the response to only objects that starts with the key
     */
    prefix?: string | undefined;
};
export type StorageListObject = {
    /**
     * Name of the object
     */
    key: string;
    /**
     * Last modified date string in ISO 8601 format
     */
    lastModified: string;
    /**
     * size of the object
     */
    size: number;
    /**
     * Temporary presigned url to fetch the object
     */
    tempGetObjectUrl: string;
    /**
     * Expiry time for tempGetObjectUrl as date string in ISO 8601 format
     */
    tempGetObjectExpiry: string;
};
export type StorageListObjectsResponse = {
    results: StorageListObject[];
};
export type StorageDeleteObjectRequest = {
    /**
     * Key of the object to be deleted
     */
    key: string;
};
/**
 * @namespace Storage
 *
 * Extension storage provides a way for extension authors to save data in a given authcontext
 * the extension is installed in without needing their own storage layer.
 *
 * Any data can be stored, and by using presigned URLs, data is stored and fetched directly via the
 * embedded view. Data is stored in AWS S3 and we provide extension authors with presigned URLs
 * for objects to be stored and fetched. This way we only act as a proxy for generating the presigned links
 * without ever having an opinion on what data is actually stored.
 *
 * NOTE: Even though extension authors can write data on behalf of a user in a specific context, it's
 * still the user who owns the data, and can they can access it without going through the extension
 * itself.
 *
 * @see https://aws.amazon.com/s3/
 */
declare class Storage {
    #private;
    constructor(iframeMessenger: IframeMessenger);
    /**
     * Add a an object to storage
     *
     * @example
     * // STORE JSON
     * const myObject = {
     *  someData: "someValue"
     * }
     *
     * await Forma.extensions.storage.setObject({key: "some-key", data: JSON.stringify(myObject)})
     *
     * @example
     * // STORE Float32Array
     *
     * function arrayToBuffer(array: Float32Array): ArrayBuffer {
     *   const buffer = new ArrayBuffer(array.length * Float32Array.BYTES_PER_ELEMENT);
     *   const arr = new Float32Array(buffer);
     *   arr.set(array);
     *   return arr;
     * }
     *
     * const arr = new Float32Array(100).fill(Math.random())
     * await Forma.extensions.storage.setObject({key: "someKey", data: arrayToBuffer(arr)})
     *
     */
    setObject(request: StorageSetObjectRequest): Promise<void>;
    /**
     * Utility function to fetch string objects without needing to decode an array buffer
     *
     * @example
     * // READING JSON
     * const res = await Forma.extensions.storage.getTextObject({key: "some-key"})
     * if (!res) {
     *    return
     * }
     * const metadata = JSON.parse(data.metadata ?? "{}")
     * const data = res.data
     *
     * @example
     * function loadImageFromEncodedPng(url: string): Promise<HtmlImageElement> {
     *   return new Promise((resolve, reject) => {
     *     const img = new Image()
     *     img.onload = () => {
     *       resolve(img)
     *     }
     *     img.onerror = () => {
     *       reject(new Error("Failed to load image"))
     *     }
     *     img.src = url
     *   })
     * }
     *
     * async function createCanvasFromDataUrl(url: string): Promise<HtmlCanvasElement | void> {
     *  const canvas = document.createElement("canvas")
     *  const ctx = canvas.getContext("2d")
     *  const img = await loadImage(url)
     *  canvas.height = img.height
     *  canvas.width = img.width
     *  ctx.drawImage(ctx, img, 0, 0)
     *  return canvas
     * }
     *
     * const res = await Forma.extensions.storage.getTextObject({key: "some-png-key"})
     * if (!res) {
     *    return
     * }
     * const canvas = createCanvasFromDataUrl(res.data)
     *
     */
    getTextObject(request: StorageGetObjectRequest): Promise<StorageGetTextObjectResponse | undefined>;
    /**
     *
     * Fetch the data on the specific key provided
     *
     * Use this function when you're **not** fetching text data, such as geometry
     * or analysis results
     *
     * @example
     * const res = await Forma.extensions.storage.getBinaryObject({key: "my-float32-array"})
     * if (!res) {
     *  return
     * }
     * const terrainSlope: Float32Array = new Float32Array(res.data)
     * const metadata = JSON.parse(res.metadata ?? "{}")
     *
     */
    getBinaryObject(request: StorageGetObjectRequest): Promise<StorageGetBinaryObjectResponse | undefined>;
    /**
     * List all storage objects for the extension in the current authcontext
     */
    listObjects(request?: StorageListObjectsRequest): Promise<StorageListObjectsResponse>;
    /**
     * Delete an object with the specific key
     */
    deleteObject(request: StorageDeleteObjectRequest): Promise<void>;
}
export {};
